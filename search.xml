<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java常用类</title>
      <link href="/2022/11/08/java-chang-yong-lei/"/>
      <url>/2022/11/08/java-chang-yong-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="java常用类"><a href="#java常用类" class="headerlink" title="java常用类"></a>java常用类</h2><ul><li><p><strong>Object类</strong></p><p>是所有类的父类。</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Object()</td><td align="center">是所有子类的父类</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖</title>
      <link href="/2022/10/30/rui-ji-wai-mai/"/>
      <url>/2022/10/30/rui-ji-wai-mai/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 项目篇 </category>
          
          <category> 笔记篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatisplus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯——杨辉三角形</title>
      <link href="/2022/10/29/lan-qiao-bei-yang-hui-san-jiao-xing/"/>
      <url>/2022/10/29/lan-qiao-bei-yang-hui-san-jiao-xing/</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://s2.loli.net/2022/10/29/4yhwpENKvXW89iS.png" alt="image-20221029200859350"></p></li><li><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p><del>刚开始的想法是，定义一个二维数组，将每一行的数字都存进去，但是因为<font color='red'>N&lt;&#x3D;1000000000</font>，开二维数组导致内存超限。</del></p><p>​仔细思考后发现，既然按行不行，那就按列来算：第一列全为1，第二列为从1开始的自然数列，第三列的数为同行的第二列的数和它上一行第二列的数相乘以后除以二的结果。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">a[n][3]&#x3D;a[n][2]*a[n-1][2]&#x2F;2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​然后推断出，第三列的数大于1000000000时，相邻的第二列数为44723，这一行的个数为44724，这是第44724行，所以可以开一个一维数组a[44725],然后公式<font color='red'>a[j]&#x3D;a[j]+a[j-1]</font>,从每一行的最左端的数看为a[n]<font color='red'>(n为行数，n从0开始）</font>开始计算，将每一行的数都存入一维数组，然后从前一行的数推出后一行的数，如果遇到这个数就直接跳出，如果计算到第44723行的第三列数仍未找到，那这个数一定会出现在第二列的第N+1行。</p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class 杨辉三角 &#123;    public static void main(String[] args) &#123;        long N,count&#x3D;0;        int i&#x3D;1,j &#x3D; 2,p;        Scanner scanner &#x3D; new Scanner(System.in);        N&#x3D;scanner.nextLong();       long[] a&#x3D;new long[44725];       a[0]&#x3D;1;&#x2F;&#x2F;初始化第一行       if(N&#x3D;&#x3D;1)&#123;           System.out.println(1);           return;       &#125;       for(i&#x3D;1;i&lt;44725;i++)&#123;&#x2F;&#x2F;从第二行开始           for(j&#x3D;i;j&gt;&#x3D;1;j--)&#123;               &#x2F;&#x2F;重点               a[j]&#x3D;a[j]+a[j-1];               &#x2F;&#x2F;               count++;               if(a[j]&#x3D;&#x3D;N)&#123;                   System.out.println(count+i);&#x2F;&#x2F;加i是因为每一行都没有算a[0]                   return;               &#125;           &#125;       &#125;        System.out.println(N*(N+1)&#x2F;2+2);&#x2F;&#x2F;计算第二列第N+1行的数是第几个    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 习题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2022/10/25/pai-xu-suan-fa/"/>
      <url>/2022/10/25/pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><ul><li><strong>稳定</strong>：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面；</li><li><strong>原地排序</strong>：在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序；</li><li><strong>非原地排序</strong>：需要利用额外的数组来辅助排序；</li></ul></blockquote><p><strong>各排序算法总结：</strong></p><p><img src="https://s2.loli.net/2022/10/25/haZ7kNejPYqKlio.png" alt="image-20220911004032768"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>冒泡排序是一种简单的排序算法，每轮比较，将未排序的最大的数字放到最后，经过n-1轮，整个数组都有序了。</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY.gif"><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY.gif" alt="img"></a></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 冒泡排序 * @param a * @return *&#x2F;public static int [] BubbleSort(int [] a)&#123;    if(a.length &#x3D;&#x3D; 0)        return a;    int len &#x3D; a.length;    for(int i&#x3D;0;i&lt;len;i++)&#123;        for(int j&#x3D;0;j&lt;len-i-1;j++)&#123;            &#x2F;&#x2F;交换两个相邻数字            if(a[j+1]&lt;a[j])&#123;                int temp &#x3D; a[j+1];                a[j+1] &#x3D; a[j];                a[j] &#x3D; temp;            &#125;        &#125;    &#125;    return a;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优化一下冒泡排序的算法</strong></p><blockquote><p>如果某一趟的遍历中，相邻的元素之间都没有发生交换的操作，这意味着右边的元素总是大于等于左边的元素，此时的数组已经是有序的了，我们无需再对剩余的元素重复比较下去了。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int[] bubbleSort(int[] arr) &#123;        if ( arr.length &#x3D;&#x3D; 0) &#123;            return arr;        &#125;        int len &#x3D; arr.length;        for (int i &#x3D; 0; i &lt; len; i++) &#123;            boolean flag &#x3D; true;            for (int j &#x3D; 0; j &lt; len -i - 1; j++) &#123;               if (arr[j + 1] &lt; arr[j]) &#123;                   flag &#x3D; false;                   int t &#x3D; arr[j];                   arr[j] &#x3D; arr[j+1];                   arr[j+1] &#x3D; t;               &#125;           &#125;           &#x2F;&#x2F;一趟下来是否发生位置交换           if(false)               break;       &#125;       return arr;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用优化后的冒泡算法，在数组本身就有序的情况下，时间复杂度为O(n)</strong></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>将数组分为已经排序和未排序两部分，初始时已排序部分元素个数为0。每次遍历，找到未排序数组中的最小元素，然后将它放在已排序数组中的末尾。经过n-1次遍历后，整个数组就是有序的了。</p><ul><li>初始状态：无序区为R[1…n]，有序区为空；</li><li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了</li></ul></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/2.gif"><img src="https://s2.loli.net/2022/10/25/3j4SH1MKDqXgoyR.gif" alt="img"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**     * 选择排序     * @param a     * @return     *&#x2F;    public static int [] SelectSort(int [] a)&#123;        if(a.length &#x3D;&#x3D; 0)            return a;        int len &#x3D; a.length;        for(int i&#x3D;0;i&lt;len;i++)&#123;            int minindex &#x3D; i;            &#x2F;&#x2F;遍历无序数组，找到最小的元素            for(int j&#x3D;i+1;j&lt;len;j++)&#123;                if(a[j] &lt; a[minindex])                    minindex &#x3D; j;            &#125;&#x2F;&#x2F;交换元素            int temp &#x3D; a[i];            a[i] &#x3D; a[minindex];            a[minindex] &#x3D; temp;        &#125;        return a;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>插入排序同样将数组分为已排序和未排序的两部分。每次遍历的时候都将当前元素和之前的元素进行比较，找到小于等于自己的元素，然后插入到他的后面；在比较过程中，大于当前元素的元素都将向后移动一位。</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/3.gif"><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/3.gif" alt="img"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 插入排序 * @param a * @return *&#x2F;public static int [] insertSort(int [] a)&#123;    if(a.length &#x3D;&#x3D; 0)        return a;    int len &#x3D; a.length;    for(int i&#x3D;1;i&lt;len;i++)&#123;        &#x2F;&#x2F;当前元素        int current &#x3D; a[i];        &#x2F;&#x2F;前一个元素的位置        int preindex &#x3D; i-1;        while(preindex&gt;&#x3D;0&amp;&amp;a[preindex] &gt; current)&#123;            &#x2F;&#x2F;将大于当前元素的值向后移动一位            a[preindex+1] &#x3D; a[preindex];            preindex--;        &#125;        &#x2F;&#x2F;退出循环是因为preindex&lt;0 或者 a[preindex] &lt;&#x3D; current        &#x2F;&#x2F;也就是说当前元素应该插入到preindex后面，所以+1        a[preindex+1] &#x3D; current;    &#125;    return a;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>希尔排序是插入排序的改进版，也叫缩小增量排序；插入排序每次只会和前面一个数字进行比较，<strong>如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n - 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了</strong>。而希尔排序会逐渐减小这个增量的值，随着增量逐渐减小，每组包含的元素越来越多，当增量为1的时候，整个数组被分成一组，算法终止。</p></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220911112014363.png"><img src="https://s2.loli.net/2022/10/25/WEvcmkY3jbDGShz.png" alt="image-20220911112014363"></a></p><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220911112014363.png">image-20220911112014363</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 希尔排序 * @param a * @return *&#x2F;public static int[] shellSort(int [] a)&#123;    if(a.length &#x3D;&#x3D; 0)        return a;    int len &#x3D; a.length;    &#x2F;&#x2F;增量选择为 len&#x2F;2，增量可以有多种选择方法    int gap &#x3D; len&#x2F;2;    while(gap&gt;0)&#123;        &#x2F;&#x2F;对于每一个增量，进行插入排序        for(int i&#x3D;gap;i&lt;len;i++)&#123;            int current &#x3D; a[i];            &#x2F;&#x2F;这里上一个元素的下标为当前下标-gap            int preindex &#x3D; i-gap;            while(preindex&gt;&#x3D;0 &amp;&amp; a[preindex]&gt;current)&#123;                a[preindex+gap] &#x3D; a[preindex];                preindex-&#x3D;gap;            &#125;            a[preindex+gap] &#x3D; current;        &#125;        gap&#x2F;&#x3D;2;    &#125;    return a;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>由上面代码可以看出，其实希尔排序就是插入排序的优化，代码也很像，只是需要每次对gap进行修改，并且元素之间的间隔不再是固定的1，而是这个gap。</strong></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>归并排序是分治法的一个典型应用。将一个大的数组分为多个子序列，对每个子序列进行排序，然后再将已经有序的子序列进行合并，得到最终的有序序列，即：<strong>先让每个子序列有序，再让子序列段间有序。</strong></p><ul><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列</li></ul></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/4.gif"><img src="https://s2.loli.net/2022/10/25/aTpP2KuOHs8mqzg.gif" alt="img"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 归并排序 * @param a * @param left * @param right * @return *&#x2F;public static int [] mergeSort(int [] a,int left,int right)&#123;    if(left &lt; right)&#123;        &#x2F;&#x2F;将大数组分成两个子数组        int mid &#x3D; left+(right-left)&#x2F;2;        &#x2F;&#x2F;对左半边进行排序        mergeSort(a,left,mid);        &#x2F;&#x2F;对右半边进行排序        mergeSort(a,mid+1,right);        &#x2F;&#x2F;合并        merge(a,left,mid,right);    &#125;    return a;&#125;public static void merge(int [] a,int left,int mid,int right)&#123;    int [] temp &#x3D; new int [right-left+1];    int i &#x3D; left;    int j&#x3D; mid+1;    int k&#x3D;0;    while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;right)&#123;        if(a[i] &lt; a[j])            temp[k++] &#x3D; a[i++];        else            temp[k++] &#x3D; a[j++];    &#125;    while(i&lt;&#x3D;mid)        temp[k++] &#x3D; a[i++];    while(j&lt;&#x3D;right)        temp[k++]&#x3D; a[j++];    &#x2F;&#x2F;将临时数组的元素复制到原数组    for(i&#x3D;0;i&lt;k;i++)&#123;        a[left++] &#x3D; temp[i];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>快速排序是选择一个基准数，将大于基准数的元素放在基准数右边，小于基准数的元素放在基准数左边。这是基准数的位置就是有序的了；在分别对左右两个子序列进行同样操作，最后达到有序。</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot ）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/5.gif"><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/5.gif" alt="img"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 快速排序 * @param * @param left 数组的左边界 * @param right 数组的右边界 * @return *&#x2F;public static void QuickSort(int[] nums, int left, int right)&#123;    if(left &lt; right)&#123;        &#x2F;&#x2F;找到基准数的有序下表        int mid &#x3D; Partition(nums,left,right);        &#x2F;&#x2F;将数组分为两部分，递归分区操作        QuickSort(nums,left,mid-1);        QuickSort(nums,mid+1,right);    &#125;&#125;public static int Partition(int []nums,int left,int right)&#123;    &#x2F;&#x2F;默认数组的第一个为基准数    int pivot &#x3D; nums[left];    int i &#x3D; left+1;    int j &#x3D; right;    while(true)&#123;        &#x2F;&#x2F;从左到右找到数组中大于基准数的值        while(i&lt;&#x3D;j &amp;&amp; nums[i] &lt;&#x3D; pivot)            i++;        &#x2F;&#x2F;从右向左找到数组中小于基准数的值        while(i&lt;&#x3D;j &amp;&amp; nums[j] &gt;&#x3D; pivot)            j--;        if(i&gt;&#x3D;j)            break;        &#x2F;&#x2F;交换这两个数，让&lt; 基准数的元素到基准数左边，&gt; 基准数的元素到基准数右边        int t &#x3D; nums[i];        nums[i] &#x3D; nums[j];        nums[j] &#x3D; t;    &#125;    &#x2F;&#x2F;将基准数放到中间，此时基准数位置有序    nums[left] &#x3D; nums[j];    nums[j] &#x3D; pivot;    return j;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>另外一种快速排序</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;随机选取基准数public static void QuickSort(int[] nums, int left, int right)&#123;        if(left &lt; right)&#123;            &#x2F;&#x2F;随机选取基准数            int randomIndex &#x3D; new Random().nextInt(right-left)+left+1;            &#x2F;&#x2F;将基准数放在数组的首部            swap(nums,left,randomIndex);            int mid &#x3D; Partition(nums,left,right);            QuickSort(nums,left,mid-1);            QuickSort(nums,mid+1,right);        &#125;    &#125;public static int Partition(int [] a,int left,int right)&#123;    int pivot &#x3D; left,index &#x3D; left+1;    &#x2F;&#x2F;此时right是下标值，因此是&lt;&#x3D;    for(int i&#x3D;index;i&lt;&#x3D;right;i++)&#123;        &#x2F;&#x2F;将小于基准数的元素放在前面来，index表示不小于基准数的第一个下标        if(a[i] &lt; a[pivot])&#123;            swap(a,index,i);            index++;        &#125;    &#125;    &#x2F;&#x2F;index由于每次执行+1，所以最后一个小于基准数的是index-1    swap(a,index-1,pivot);    return index-1;&#125;&#x2F;&#x2F;交换两个元素public static void swap(int [] a,int left,int right)&#123;    int temp &#x3D; a[left];    a[left] &#x3D; a[right];    a[right] &#x3D; temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在选择基准数的时候，如果每次选取的都是当前子序列中的最小值或者最大值，那么经过一次遍历之后，其他元素的位置没有变化。那么就有点像选择排序，时间复杂度为O(n²)。当数组已经有序时，如果选择的不是随机基准数会出现这种情况。</strong></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>堆排序是利用堆这种数据结构，构建一个大顶堆，将大顶堆的堆顶元素与堆的最后一个值进行交换，并重新构建大顶堆。由大顶堆堆顶是最大值，因此交换之后数组的最后一个值为最大值，此时有序。</p><p><strong>大顶堆性质：子节点的值一定小于父节点的值。</strong></p><p><strong>在数组中，2*index+1是左节点，2*index+2是左节点</strong></p></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/7.gif"><img src="https://s2.loli.net/2022/10/25/kltenw6VBco41IM.gif" alt="img"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 堆排序 * @param nums *&#x2F;public static void heapSort(int [] nums)&#123;    int len &#x3D; nums.length;    &#x2F;&#x2F;构架大顶堆    buildMaxHeap(nums,len-1);    for(int i &#x3D; len-1;i&gt;&#x3D;1;i--)&#123;        &#x2F;&#x2F;将堆顶放到数组末尾，因为堆顶是最大值，经过这次，最大值有序        int temp &#x3D; nums[i];        nums[i] &#x3D; nums[0];        nums[0] &#x3D; temp;        &#x2F;&#x2F;通过下沉重新构建大顶堆        adjustHeap(nums,0,i-1);    &#125;&#125;&#x2F;** * 构建大顶堆 * @param nums *&#x2F;public static void buildMaxHeap(int [] nums,int length)&#123;    &#x2F;&#x2F;根据大顶堆的特性，一个字节的值大于等于其子节点的值    &#x2F;&#x2F;所以需要调节每一个有子节点的节点和它的子节点的关系。    &#x2F;&#x2F;因此从(length-1)&#x2F;2开始，这是最后一个非叶子节点    for(int i&#x3D;(length-1)&#x2F;2;i&gt;&#x3D;0;i--)&#123;        &#x2F;&#x2F;对非叶子节点通过下沉来构架大顶堆,        adjustHeap(nums,i,length);    &#125;&#125;&#x2F;** * 下沉操作 * @param nums * @param parent * @param n *&#x2F;public static void adjustHeap(int []nums,int parent,int n)&#123;    &#x2F;&#x2F;记录当前值    int temp &#x3D; nums[parent];    &#x2F;&#x2F;左孩子    int child &#x3D; 2*parent+1;    while(child &lt;&#x3D;n)&#123;        &#x2F;&#x2F;需要将子节点中较大值和父节点进行比较        &#x2F;&#x2F;经过这个if，child是子节点中的较大值        if(child+1&lt;&#x3D;n&amp;&amp;nums[child] &lt; nums[child+1])            child++;        if(nums[child] &lt;&#x3D;temp)            break;        &#x2F;&#x2F;将子节点上浮到父节点位置，父节点下沉到子节点位置        nums[parent] &#x3D; nums[child];        parent &#x3D; child;        child &#x3D; 2*parent+1;    &#125;    nums[parent] &#x3D; temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建时踩过的坑</title>
      <link href="/2022/10/23/ge-ren-bo-ke-da-jian-shi-cai-guo-de-keng/"/>
      <url>/2022/10/23/ge-ren-bo-ke-da-jian-shi-cai-guo-de-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>​经过这几天的忙碌，我的博客也差不多大功告成，当然还有一些细节需要优化。这篇文章主要是对我在搭建博客的过程中踩过的坑做一个总结，希望能帮到遇到同样bug的人。</p></blockquote><h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><ul><li><p>node.js</p></li><li><p>git</p></li><li><p>编辑器（例如：IntelliJ IDEA、VScode)</p></li></ul><p>（温馨提示：node.js安装后需要配置环境变量，本文不做详细介绍，可自行Google，不难，另外最好不要去官网下载，速度特别慢）</p><h2 id="在Github下建自己的博客仓库"><a href="#在Github下建自己的博客仓库" class="headerlink" title="在Github下建自己的博客仓库"></a>在Github下建自己的博客仓库</h2><p>​仓库名称最好为”你的github名称.github.io”,另外github账户名称最好不要用大写字母。</p><h2 id="使用hexo-script脚本安装hexo"><a href="#使用hexo-script脚本安装hexo" class="headerlink" title="使用hexo-script脚本安装hexo"></a>使用hexo-script脚本安装hexo</h2><p>​以上操作完成无误后，首先需要新建一个目录blog，然后<a href="https://hexoscript.gitbook.io/hexo-script/v/1.3-1/shi-yong-bu-zhou/zhun-bei-gong-ju">点击这里</a>进入到下方页面</p><p><img src="https://s2.loli.net/2022/10/24/LzxshrMYy5XNc3d.png" alt="image-20221024215200630"></p><p>​根据上面的教程可以自行安装。</p><h2 id="我踩过的的坑"><a href="#我踩过的的坑" class="headerlink" title="我踩过的的坑"></a>我踩过的的坑</h2><ul><li><h3 id="设置SSH密匙"><a href="#设置SSH密匙" class="headerlink" title="设置SSH密匙"></a>设置SSH密匙</h3><p>​首先在执行教程时，一定要检查自己的C:\Users\你的用户名.ssh路径下是否包含以下两个文件，没有的话需要在桌面单击右键打开git bash窗口，输入以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C  &quot;2018XXXX98@qq.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>记得换成自己的邮箱</p></li></ul><p><img src="https://s2.loli.net/2022/10/24/TFodyqrngvQYupf.png" alt="image-20221024220044123"></p><p>然后到自己的github中进行以下设置<img src="https://s2.loli.net/2022/10/24/1iukBstCrXwKpyR.png" alt="image-20221024220943278"></p><ul><li><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><ol><li><p>​刚开始部署博客时如果无论如何都无法出现博客首页，一定要到自己的github仓库下，点击setting，进行如下设置：<img src="https://s2.loli.net/2022/10/24/w3cnJxjahrQDHCp.png" alt="image-20221024221543301"></p></li><li><p>​        使用Git将博客部署到远程仓库时，使用的命令依次是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean  &#x2F;&#x2F;清理之前的部署hexo g      &#x2F;&#x2F;在hexo站点根目录下生成public文件夹hexo s      &#x2F;&#x2F;在本地开启hexo，可跳过hexo d      &#x2F;&#x2F;将代码提交到远程仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>​        执行<strong>hexo   d</strong>是出现<strong>Spawn failed</strong>错误</p></li><li><p><img src="https://s2.loli.net/2022/10/29/PLlI2Dhg1aeZXQn.png" alt="image-20221029193638212"></p><ul><li>问题原因<ol><li>Git向远程仓库push文件的时候发生更改</li><li>网络原因</li></ol></li><li>解决方法</li></ul><p>首先进入自己博客的根目录，删除**.deploy_git<strong>文件，然后在</strong>git bash**中执行下面代码：</p><pre class="line-numbers language-none"><code class="language-none">git config --global core.autocrlf false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后重新进行部署。</p></li></ol></li><li><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>​       一般部署好自己的个人网站后都会更换主题，我的主题是<a href="https://github.com/blinkfox/hexo-theme-matery">matery</a>，当然大家可以<a href="https://hexo.io/themes/index.html">单击这里</a>选择自己心仪的主题,基本的配置大家都可以参考配置文档。</p><p>我的blog首页：</p><p><img src="https://s2.loli.net/2022/10/24/BdAtKO3uQylYzWR.png" alt="image-20221024223151003"></p><ol><li><h4 id="添加valine评论功能"><a href="#添加valine评论功能" class="headerlink" title="添加valine评论功能"></a>添加valine评论功能</h4><ul><li>问题描述</li></ul><p>​       参照配置文档开启valine评论功能之后，结果发现不仅在标签、分类、归档、友链下面全部出现了评论功能，而我只需要在留言板下出现评论功能即可，在网上找了很久，居然没有一篇文章提到这个问题。</p><ul><li>解决方法</li></ul><p>​     只需要在标签、分类、归档目录下的index.md文件的front matter中的comments标签设置为false即可。</p><p><img src="https://s2.loli.net/2022/10/29/agyTF36k9rjMOhB.png" alt="image-20221029172759947"></p><ul><li><p>不足</p><p>​       使用上述方法后，在标签、分类、归档标签页下有效，但是友链下面虽然设置了comment: false,仍然出现valine评论，后续有待完善。</p></li></ul><p></p></li><li><h4 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="[未完待续。。。]"></a>[未完待续。。。]</h4></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> matery </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/21/hello-world/"/>
      <url>/2022/10/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
