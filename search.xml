<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="/2022/11/11/markdown-chang-yong-yu-fa/"/>
      <url>/2022/11/11/markdown-chang-yong-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><code>Markdown</code> 是一种可以使用普通文本编辑器编写的轻量级标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，可以导出 <code>PPT、LaTex、HTML、Word、PDF、Epub、JPG</code> 等多种格式的文档，文档后缀为 <code>.md</code>。相比于其它语言，markdown更美观，排版简单，学习成本极低，无论是博客，笔记还是论文等等，都是基于它写的！！！</p><p>常见的Markdown语法编辑器：<a href="https://typora.io/">Typora</a>（推荐）、<a href="https://code.visualstudio.com/">Vscode</a>。</p><p>包括市面上常见的各种编程软件都自带Markdown编辑功能。</p></blockquote><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><ol><li><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><ul><li>markdown中的标题一共分为六个级别</li><li>每一级标题对应一个#号</li></ul><p>如下：</p><pre class="line-numbers language-none"><code class="language-none"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示效果如下：</p><p><img src="https://s2.loli.net/2022/11/12/zLvUx2Hd4hpyZao.png" alt="标题"></p></li><li><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ul><li>斜体文本：可以在需要标注为斜体文本前及斜体文本结尾，输入一个星号 * 或者一个下划线 _；</li><li>粗体文本：可以在需要标注为粗体文本前及粗体文本结尾，输入两个星号 ** 或者两个下划线_；</li><li>粗斜体文本：可以在需要标注为粗斜体文本前及粗斜体文本结尾，输入三个星号 *** 或者三个下划线 _；</li></ul><p>如下：</p><pre class="line-numbers language-none"><code class="language-none">*斜体*_斜体_**粗体**__粗体__***粗斜体***___粗斜体___<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示效果如下：</p><p><img src="https://s2.loli.net/2022/11/12/UF7j2LwgeaDVxcH.png" alt="文本"></p></li><li><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><pre class="line-numbers language-none"><code class="language-none">[链接名称](链接地址)或&lt;链接地址&gt;举例：[我的博客](https:&#x2F;&#x2F;hcl274.github.io&#x2F;)或&lt;https:&#x2F;&#x2F;hcl274.github.io&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示效果如下：</p><p><img src="https://s2.loli.net/2022/11/12/9Q3zw7yBhbnXRoL.png" alt="超链接"></p></li><li><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>无序列表，使用星号(<code>*</code>)、加号(<code>+</code>)或是减号(<code>-</code>)，再加一个空格作为列表标记；</li><li>有序列表，使用数字并加上 <code>.</code> 号，再加一个空格作为列表标记。</li></ul><p>如下：</p><pre class="line-numbers language-none"><code class="language-none">* 无序列表 1+ 无序列表 2- 无序列表 31. 有序列表 12. 有序列表 23. 有序列表 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示效果如下：</p><p><img src="https://s2.loli.net/2022/11/12/VNoQRq75Uymb4Yr.png" alt="有序列表"></p><p>如果要控制列表的层级，则需要在符号 <code>-</code> 前使用 <code>tab</code>，如下：</p><pre class="line-numbers language-none"><code class="language-none">- 无序列表 1- 无序列表 2- 无序列表 2.1- 无序列表 2.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>显示效果如下：</p><p><img src="https://s2.loli.net/2022/11/12/GfbamwjUVrLNpTy.png" alt="无序列表"></p></li><li><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用的格式是在符号 <code>&gt;</code> 后面书写文字，或者加一个空格再加文字，如下：</p><pre class="line-numbers language-none"><code class="language-none">&gt; 这是一个引用：&gt; 欢迎前往我的博客&gt; &lt;https:&#x2F;&#x2F;hcl274.github.io&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>显示效果如下：</p><p><img src="https://s2.loli.net/2022/11/12/6ZPGKLsihaTnvJ7.png" alt="引用"></p></li><li><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>可以在一行中用三个 <code>-</code> 或者 <code>*</code> 来建立一个分隔线，同时需要在分隔线的上面空一行，如下：</p><pre class="line-numbers language-none"><code class="language-none">欢迎来到我的博客---Hello,welcome to my blog或者**** * ******- - - <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示效果如下：</p><p><img src="https://s2.loli.net/2022/11/12/lGNb4zQHYcaPieA.png" alt="分割线"></p></li><li><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线的使用，在需要添加下划线的文字首部和尾部加上 <code>&lt;u&gt;文本&lt;/u&gt;</code>，如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;u&gt;这行文字已被添加下划线&lt;&#x2F;u&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示效果如下：</p><p><img src="https://s2.loli.net/2022/11/12/Jrm4kPcnH8aSqeF.png" alt="下划线"></p></li><li><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>删除线的使用，在需要删除的文字前后各使用两个 <code>~</code>，如下：</p><pre class="line-numbers language-none"><code class="language-none">~~要删除的内容~~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示效果如下：</p><p><img src="https://s2.loli.net/2022/11/12/xXU2BjaCHkqrweQ.png" alt="删除线"></p></li><li><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行，如果想调整表格的左对齐、右对齐、居中对齐:</p><ul><li><code>:-</code>：将表头及单元格的内容左对齐；</li><li><code>-:</code>：将表头及单元格的内容左对齐；</li><li><code>:-:</code>：将表头及单元格的内容居中对齐；</li></ul><p>如下：</p><pre class="line-numbers language-none"><code class="language-none">| 姓名   | 年龄 |      工作 || :----- | :--: | -------: || 小可爱 |  18  | 吃可爱多  || 小小勇敢 |  20  | 爬棵勇敢树  || 小小小机智 |  22  | 看一本机智书 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示效果如下：</p><p><img src="https://s2.loli.net/2022/11/12/7UlnhPkXT3IZpwE.png" alt="列表"></p></li><li><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3></li><li><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3></li><li><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>如果在一个行内需要引用代码，只要用反引号引起来就好，如下：</p><pre class="line-numbers language-none"><code class="language-none">Use the &#96;printf()&#96; function.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示效果如下：</p><p><img src="https://s2.loli.net/2022/11/12/LwIlOWyubZdmvFs.png" alt="行内代码块"></p><p>如果是在一个块内需要引用代码，则在需要高亮的代码块的前一行及后一行使用三个反引号，同时 <strong>第一行反引号后面表示代码块所使用的语言</strong>，如下：</p><pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;cpp   #include&lt;iostream&gt;   int main()&#123;   printf(&quot;HelloWorld&quot;);   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">显示效果如下：&#96;&#96;&#96;cpp    #include&lt;iostream&gt;    int main()&#123;    printf(&quot;HelloWorld&quot;);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持以下语言种类：</p><pre class="line-numbers language-none"><code class="language-none">bashc，clojure，cpp，cs，cssdart，dockerfile, differlanggo，gradle，groovyhaskelljava，javascript，json，juliakotlinlisp，luamakefile，markdown，matlabobjectivecperl，php，pythonr，ruby，rustscala，shell，sql，swifttex，typescriptverilog，vhdlxmlyaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【未完待续。。。】</p></li></ol><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 笔记篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java常用类</title>
      <link href="/2022/11/08/java-chang-yong-lei/"/>
      <url>/2022/11/08/java-chang-yong-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="java常用类"><a href="#java常用类" class="headerlink" title="java常用类"></a>java常用类</h2><ul><li><p><strong>Object类</strong></p><p>是所有类的父类。</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Object clone()</td><td align="center">创建与该对象的类相同的新对象</td></tr><tr><td align="center">boolean equals(Object)</td><td align="center">比较两个对象是否相等。默认比较的是地址值。</td></tr><tr><td align="center">void finalize()</td><td align="center">当垃圾回收器确定不存在对该对象的更多引用时，对象的圾回收器调用该方法</td></tr><tr><td align="center">Class getClass()</td><td align="center">返回一个对象运行时的实例类（.class文件）</td></tr><tr><td align="center">int hashCode()</td><td align="center">返回该对象的散列码值</td></tr><tr><td align="center">void notify()</td><td align="center">激活等待在该对象的监视器上的一个线程</td></tr><tr><td align="center">void notifyAll()</td><td align="center">激活等待在该对象的监视器上的全部线程</td></tr><tr><td align="center">String toString()</td><td align="center">返回该对象的字符串表示，默认返回运行时类名+@+对象的hashCode的16进制数</td></tr><tr><td align="center">void wait()</td><td align="center">在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待</td></tr></tbody></table></li></ul><p>注意：</p><ul><li><p>如果两个对象的哈希码值不同，那这两个对象一定不等；</p></li><li><p>如果两个对象的哈希码值相同，不能确保这两个对象一定相等。</p></li><li><p>克隆对象对应的类需要实现Cloneable接口，否则会报错：java.lang.CloneNotSupportedException</p></li></ul><p><strong>如何获取类的字节码文件对象？</strong></p><ol><li><p>类名.class 说明： JVM将使用类装载器, 将类装入内存(前提是:类还没有装入内存),不做类的初始化工作.返回Class的对象</p></li><li><p>Class.forName(“类名字符串”) （注：类名字符串是包名+类名） 说明：装入类,并做类的静态初始化，返回Class的对象</p></li><li><p>实例对象.getClass() 说明：对类进行静态初始化、非静态初始化； 返回引用o运行时真正所指的对象(因为:子对象的引用可能会赋给父对象的引用变量中) 所属的类的Class的对象</p></li></ol><p><strong>常覆写Object类的3个方法：toString(),equals(Object obj),hashCode()</strong></p><p> <strong>为什么notify(), wait()等函数定义在Object中，而不是Thread中?</strong></p><p>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。</p><p>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获   取不到该“同步锁”而无法运行！</p><p>OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。</p><p>负责唤醒等待线程的那个线程(我们称为“唤醒线程”)，它只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p><p>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。</p><ul><li><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3></li></ul><p>​表示的是字符串，字符串是常量（值定义了之后，不可修改）</p><ol><li><p><em><strong>构造方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">String()</td><td align="center">创建一个空的字符串</td></tr><tr><td align="center">String(byte[] bys)</td><td align="center">通过字节数组创建字符串</td></tr><tr><td align="center">String(char[] chs)</td><td align="center">通过字符数组创建字符串</td></tr><tr><td align="center">String(byte[] bys,int offset,int length)</td><td align="center">通过字节数组一部分创建字符串</td></tr><tr><td align="center">String(char[] chs,int offset,int length)</td><td align="center">通过字符数组一部分创建字符串</td></tr><tr><td align="center">String(String original)</td><td align="center">通过字符串常量值创建字符串</td></tr></tbody></table></li><li><p><em><strong>成员方法</strong></em></p><p>判断功能</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">equals(Object obj)</td><td align="center">比较两个字符串是否相等</td></tr><tr><td align="center">equalsIngnoreCase(Object obj)</td><td align="center">忽略大小写比较两个字符串是否相等</td></tr><tr><td align="center">contains(String str)</td><td align="center">是否包含指定字符串</td></tr><tr><td align="center">startsWith(String str)</td><td align="center">是否以指定的字符串开头</td></tr><tr><td align="center">endWith(String str)</td><td align="center">是否以指定的字符串结尾</td></tr><tr><td align="center">isEmpty()</td><td align="center">是否为空</td></tr><tr><td align="center">matches(String regex)</td><td align="center">判断字符串是否匹配给定的正则表达式</td></tr></tbody></table><p>获取功能</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">length()</td><td align="center">获取长度</td></tr><tr><td align="center">charAt(int index)</td><td align="center">获取指定索引位置处的字符</td></tr><tr><td align="center">indexOf(int ch)</td><td align="center">获取指定字符第一次出现的索引值(从0开始)</td></tr><tr><td align="center">indexOf(int ch,int fromIndex)</td><td align="center">获取从指定索引位置开始，获取指定字符第一次出现的索引值</td></tr><tr><td align="center">indexOf(String s)</td><td align="center">获取指定字符串第一次出现的索引值</td></tr><tr><td align="center">indexOf(String s,int fromIndex)</td><td align="center">获取从指定索引位置开始，获取指定字符串第一次出现的索引值</td></tr><tr><td align="center">lastIndexOf(int ch)</td><td align="center">获取指定字符最后一次出现的索引值</td></tr><tr><td align="center">substring(int start)</td><td align="center">从指定位置开始一直截取到末尾</td></tr><tr><td align="center">substring(int start,int end)</td><td align="center">截取[start,end-1]范围</td></tr></tbody></table><p>转换功能</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">byte[] getBytes()</td><td align="center">将字符串转成字节数组</td></tr><tr><td align="center">char[] toCharArray()</td><td align="center">将字符串转成字符数组</td></tr><tr><td align="center">static valueOf(char[] chs)</td><td align="center">将char[]转成字符串</td></tr><tr><td align="center">static valueOf(int num)</td><td align="center">将int类型转成字符串</td></tr><tr><td align="center">static valueOf(Object obj)</td><td align="center">将任意类型转成字符串</td></tr><tr><td align="center">toLowerCase()</td><td align="center">转成小写</td></tr><tr><td align="center">toUpcase()</td><td align="center">转成大写</td></tr><tr><td align="center">concat(String str)</td><td align="center">字符连接</td></tr></tbody></table><p>其他功能</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">replace(char old,char new)</td><td align="center">将old字符替换成new字符</td></tr><tr><td align="center">replace(String old,String new)</td><td align="center">将old字符串替换成new字符串</td></tr><tr><td align="center">trim()</td><td align="center">去除两边空格</td></tr><tr><td align="center">int compareToIgnoreCase(String s)</td><td align="center">忽略大小写字典比较</td></tr><tr><td align="center">int compareTo(String s)</td><td align="center">字典比较，如果前面值小于后面值返回负数，否则返回正数，先比较第一个元素，如果相等再比较第二个元素…返回元素之间的差值；如果比较字符串有包含关系，返回的值是它们长度的差值</td></tr><tr><td align="center">String replaceAll(String regex, String replacement)</td><td align="center">使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串</td></tr><tr><td align="center">String replaceFirst(String regex, String replacement)</td><td align="center">使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串</td></tr><tr><td align="center">String[] split(String regex)</td><td align="center">根据给定正则表达式的匹配拆分此字符串</td></tr><tr><td align="center">String[] split(String regex, int limit)</td><td align="center">根据匹配给定的正则表达式来拆分此字符串</td></tr></tbody></table></li></ol><ul><li><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3>线程不安全的可变字符序列</li></ul><ol><li><p><em><strong>构造方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">StringBuilder()</td><td align="center">以默认容量创建空的StringBuilder对象</td></tr><tr><td align="center">StringBuilder(int capacity)</td><td align="center">以指定容量创建空的StringBuilder对象</td></tr><tr><td align="center">StringBuilder(String str)</td><td align="center">以指定的字符串创建StringBuilder对象</td></tr></tbody></table></li><li><p><em><strong>成员方法</strong></em></p><p>获取功能</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">int capacity()</td><td align="center">获取容量</td></tr><tr><td align="center">int length()</td><td align="center">获取长度</td></tr></tbody></table><p>添加功能</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">append(int value)</td><td align="center">追加。可以追加多种类型</td></tr><tr><td align="center">insert(int offset,String s）</td><td align="center">在指定的位置插入指定数据</td></tr></tbody></table><p>删除功能</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">deleteCharAt(int index)</td><td align="center">删除指定索引处的元素</td></tr><tr><td align="center">delete(int start,int end)</td><td align="center">删除[start,start-1]范围内的元素</td></tr></tbody></table><p>替换功能</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">replace(int start,int end,String s)</td><td align="center">将[start,end-1]范围内的元素替换成指定字符串</td></tr></tbody></table><p>反转功能</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">reverse()</td><td align="center">元素反转</td></tr></tbody></table><p>截取功能</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">String subString(int start)</td><td align="center">截取指定位置一直到末尾</td></tr><tr><td align="center">String subString(int start,int end)</td><td align="center">截取[start,end-1]范围</td></tr></tbody></table><p><strong>String、StringBuilder和StringBuffer的区别？</strong><br>String内容不可改变<br>StringBuilder和StringBuffer内容可变<br>StringBuilder是线程不安全的，不同步，效率高<br>StringBuffer是线程安全的，同步，效率低</p></li></ol><ul><li><h3 id="输入——Scanner类"><a href="#输入——Scanner类" class="headerlink" title="输入——Scanner类"></a>输入——Scanner类</h3>最简单的方式，不过比较慢。</li></ul><ol><li><p><em><strong>构造方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Scanner(InputStream is)</td><td align="center">构造一个文本扫描器，它生成的值是从指定的值输入流扫描的</td></tr><tr><td align="center">Scanner( System.in )</td><td align="center">是一个标准的输入流，属于InputStream</td></tr></tbody></table></li><li><p><em><strong>成员方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">boolean hasNext()</td><td align="center">是否有下一个数,有true，没有false</td></tr><tr><td align="center">String next()</td><td align="center">获取下一个字符串</td></tr><tr><td align="center">String nextLine()</td><td align="center">获取一行字符串</td></tr><tr><td align="center">int nextInt()</td><td align="center">输入一个整数</td></tr><tr><td align="center">double nextDouble()</td><td align="center">输入一个小数</td></tr></tbody></table></li></ol><ul><li><h3 id="输入——BufferedReader类"><a href="#输入——BufferedReader类" class="headerlink" title="输入——BufferedReader类"></a>输入——BufferedReader类</h3><p>从字符输入流中读取文本，缓冲字符，以便有效地读取字符，数组和行。</p><p>可以指定缓冲区大小，或者可以使用默认大小。 对于大多数用途，默认值足够大。</p></li></ul><ol><li><p><em><strong>构造方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BufferedReader(Reader in)</td><td align="center">接收一个Reader类的实例</td></tr></tbody></table></li><li><p><em><strong>成员方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">int  read()</td><td align="center">返回读取到的第一个字符的ASCII码</td></tr><tr><td align="center">String  readLine()</td><td align="center">读取一整行字符，以enter键结尾</td></tr><tr><td align="center">int  read(char cbuf[], int off, int len)</td><td align="center">读取len个字符，然后从cbuf[off]开始存放，返回读取的字符个数</td></tr></tbody></table><p>具体用法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class BufferedReaderTest &#123;    public static void main(String[] args) throws IOException &#123;        InputStreamReader is &#x3D; new InputStreamReader(System.in);        BufferedReader buf &#x3D; new BufferedReader(is);        System.out.print(&quot;read()方法输入：&quot;);        int read &#x3D; buf.read(); &#x2F;&#x2F;read()方法输入        int read1 &#x3D; buf.read();&#x2F;&#x2F;读取换行符，防止被readLine()读取到        System.out.print(&quot;readLine()方法输入：&quot;);        String s &#x3D; buf.readLine();&#x2F;&#x2F;readLine()方法开始输入        char[] a&#x3D;new char[10];        System.out.print(&quot;read(char cbuf[], int off, int len)方法输入：&quot;);        int num &#x3D; buf.read(a, 0, 10);&#x2F;&#x2F; read(char cbuf[], int off, int len)方法输入        System.out.println(&quot;read()方法输出：&quot;+(char) read);        System.out.println(&quot;readLine()方法输出：&quot;+s);        System.out.print(&quot;read(char cbuf[], int off, int len)方法输出：&quot;);        for(char c:a)&#123;            System.out.print(c);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出内容如下：<img src="https://s2.loli.net/2022/11/09/64u5GSQn7R8POwd.png" alt="image-20221109182524512"></p><p><strong>注意</strong></p><p>readLine()方法输入时应注意不要读到换行符。</p></li></ol><ul><li><h3 id="快速输入——StreamTokenizer类"><a href="#快速输入——StreamTokenizer类" class="headerlink" title="快速输入——StreamTokenizer类"></a>快速输入——StreamTokenizer类</h3><p>StreamTokenizer类接受输入流并将其解析为“标记”，允许一次读取一个标记</p><p>注意：StreamTokenizer只能接收数字或字母，如果输入除空格和回车以外的字符<br>（如：~!@#$%^&amp;*()_+{}:&lt;&gt;?)无法识别，会显示null。</p><p>同时，如果该输入字符串时却输入数字会显示null，该输入数字时输入字符串也会显示null。</p></li></ul><ol><li><p><em><strong>构造方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">StreamTokenizer(Reader r)</td><td align="center">接收一个Reader类的实例</td></tr></tbody></table></li><li><p><em><strong>成员方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">int nextToken()</td><td align="center">解析此tokenizer的输入流中的下一个标记， 每次调用sval或nval时候都需要调用一下</td></tr><tr><td align="center">String sval()</td><td align="center">输入一个字符串</td></tr><tr><td align="center">double nval()</td><td align="center">输入数字</td></tr><tr><td align="center">static int TT_EOL</td><td align="center">一个常量，表示已读取行尾</td></tr></tbody></table><p>具体用法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.StreamTokenizer;public class StreamTokenizerTest &#123;    public static void main(String[] args) throws IOException &#123;        StreamTokenizer in &#x3D; new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));        System.out.print(&quot;字符串输入：&quot;);        in.nextToken(); &#x2F;&#x2F; 解析下一个标记。每次调用sval或nval时候都需要调用一下        String str &#x3D; in.sval; &#x2F;&#x2F; 输入字符串        System.out.println(&quot;字符串输出:&quot;+str);        System.out.print(&quot;数字输入：&quot;);        in.nextToken(); &#x2F;&#x2F; 解析下一个标记。每次调用sval或nval时候都需要调用一下        double num &#x3D; in.nval; &#x2F;&#x2F; 输入数字        System.out.println(&quot;数字输出：&quot;+num);        &#x2F;** 循环输入字符串 *&#x2F;            while (in.nextToken() !&#x3D; StreamTokenizer.TT_EOL) &#123; &#x2F;&#x2F; 当下一个输入不是行末尾时                String str2 &#x3D; in.sval; &#x2F;&#x2F; 输入字符串                System.out.println(str2);            &#125;        &#x2F;** 循环输入数字 *&#x2F;            while (in.nextToken() !&#x3D; StreamTokenizer.TT_EOL) &#123; &#x2F;&#x2F; 当下一个输入不是行末尾时                double num2 &#x3D; in.nval; &#x2F;&#x2F; 输入数字                System.out.println(num2);            &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li><h3 id="快速输出——PrintWriter类"><a href="#快速输出——PrintWriter类" class="headerlink" title="快速输出——PrintWriter类"></a>快速输出——PrintWriter类</h3>这种方式只能读取数字和字母字符串， 不能读取空格和其他字符。</li></ul><ol><li><p><em><strong>构造方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">PrintWriter(OutputStream out)</td><td align="center">从现有的OutputStream创建一个没有自动行刷新的新PrintWriter</td></tr></tbody></table></li><li><p><em><strong>成员方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">print()</td><td align="center">打印一个常量</td></tr><tr><td align="center">println()</td><td align="center">打印一个常量并终止该行</td></tr><tr><td align="center">flush()</td><td align="center">刷新流，应在每次输出后调用</td></tr></tbody></table></li></ol><ul><li><h3 id="快速输出——BufferedWriter类"><a href="#快速输出——BufferedWriter类" class="headerlink" title="快速输出——BufferedWriter类"></a>快速输出——BufferedWriter类</h3><p>从字符输入流中读取文本，缓冲字符，以便有效地读取字符，数组和行。</p><p>可以指定缓冲区大小，或者可以使用默认大小。 对于大多数用途，默认值足够大。</p><p>主要使用 BufferedWriter类中的 write() 类进行输出。 <strong>当数据量大的时候一定要使用这个类进行输出，谨记！</strong></p></li></ul><ol><li><p><em><strong>构造方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BufferedReader(Reader in)</td><td align="center">创建使用默认大小的输入缓冲区的缓冲字符输出流</td></tr></tbody></table></li><li><p><em><strong>成员方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">write(int c)</td><td align="center">输出一个字符</td></tr><tr><td align="center">write(char[] cbuf,  int off, int len)</td><td align="center">写一个字符数组的一部分</td></tr><tr><td align="center">write(String s, int off,  int len)</td><td align="center">写一个字符串的一部分</td></tr><tr><td align="center">flush()</td><td align="center">刷新流，每次输出后调用</td></tr></tbody></table><p><strong>注意</strong></p><p> 需要注意的是 write() 不能直接输出int类型，因为write(int a) 会输出其对应的ASCii码的字符</p><p>所以当需要输出一个int类型的变量时， 可以用Integer.toString(int a)方法 将其变为字符串形式输出。或者使用 + 拼接一个字符串，这样 参数整体就是一个字符串了，比如加一个换行符。</p></li></ol><ul><li><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">abs(int a)</td><td align="center">绝对值</td></tr><tr><td align="center">ceil(double d)</td><td align="center">向上取整</td></tr><tr><td align="center">floor(double d)</td><td align="center">向下取整</td></tr><tr><td align="center">max(int a,int b)</td><td align="center">最大值</td></tr><tr><td align="center">pow(double a,double b)</td><td align="center">a的b次幂</td></tr><tr><td align="center">random()</td><td align="center">随机数[0.0,1.0]</td></tr><tr><td align="center">round(float f)</td><td align="center">四舍五入</td></tr><tr><td align="center">sqrt(double d)</td><td align="center">算术平方根</td></tr></tbody></table></li><li><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3></li></ul><ol><li><p><em><strong>构造方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Random()</td><td align="center">以当前时间毫秒值作为种子，创建Random对象</td></tr><tr><td align="center">Random(long seed)</td><td align="center">以指定种子创建Random对象</td></tr></tbody></table></li><li><p><em><strong>成员方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">nextInt()n</td><td align="center">生成1个int类型范围的随机数</td></tr><tr><td align="center">nextInt(int n)</td><td align="center">产生1个[0,n-1]范围内的随机数</td></tr></tbody></table></li></ol><ul><li><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3>表示特定的瞬间，精确到毫秒值</li></ul><ol><li><p><em><strong>构造方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Date()</td><td align="center">以当前时间毫秒值创建Date对象</td></tr><tr><td align="center">Date(long time)</td><td align="center">以指定的毫秒值创建Date对象</td></tr></tbody></table></li><li><p><em><strong>成员方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">long getTime()</td><td align="center">获取Date对象的毫秒值</td></tr><tr><td align="center">setTime(long time)</td><td align="center">设置Data对象的毫秒值</td></tr></tbody></table></li></ol><ul><li><h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3></li><li><h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3></li><li><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3></li><li><h3 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h3></li></ul><ol><li><p><em><strong>构造方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BigInteger(String s)</td><td align="center">通过字符串创建BigInteger对象</td></tr></tbody></table></li><li><p><em><strong>成员方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">add(BigInteger bi)</td><td align="center">大数相加</td></tr><tr><td align="center">subtract(BigInteger bi)</td><td align="center">大数相减</td></tr><tr><td align="center">multiply(BigInteger bi)</td><td align="center">大数相乘</td></tr><tr><td align="center">divide(BigInteger bi)</td><td align="center">大数相除</td></tr></tbody></table></li></ol><ul><li><h3 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h3>用于解决浮点型运算精度损失的问题</li></ul><ol><li><p><em><strong>构造方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BigDecimal(String s)</td><td align="center">通过字符创建BigDecimal对象</td></tr></tbody></table></li><li><p><em><strong>成员方法</strong></em></p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">add(BigDecimal bi)</td><td align="center">大数相加</td></tr><tr><td align="center">subtract(BigDecimal bi)</td><td align="center">大数相减</td></tr><tr><td align="center">multiply(BigDecimalbi)</td><td align="center">大数相乘</td></tr><tr><td align="center">divide(BigDecimalbi)</td><td align="center">大数相除</td></tr></tbody></table></li></ol><ul><li><h3 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h3><p>该类包含用于操作数组的各种方法（例如排序和搜索）。此类还包含一个静态工厂，允许将数组视为链表。</p><p>如果指定的数组引用为null，则此类中的方法都抛出<code>NullPointerException</code>  ，除非另有说明。</p><table><thead><tr><th align="center">常用方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">int binarySearch(Object[] a, Object key)</td><td align="center">二分法查找给定值的索引，数组在调用之前必须是排序好的</td></tr><tr><td align="center">booleanequals(int[] a,int[] a1)</td><td align="center">两个指定int型数组彼此相等，则返回true，也就是两个数组以相同顺序包含相同的元素，方法适用于（byte,short.,long等）</td></tr><tr><td align="center">voidfill(int[] a,int val)</td><td align="center">将指定的int值分配给数组中的所有元素，方法也同样适用于（byte,short.,long等）</td></tr><tr><td align="center">voidsort(int[] a)</td><td align="center">对数组中的元素进行升序排列，方法也同样适用于（byte,short.,long等）</td></tr><tr><td align="center">intcopyof(int[] a,int newLength)</td><td align="center">使用零复制指定的数组，截断或填充（如有必要），以使副本具有指定的长度。 方法也同样适用于（byte,short.,long等）</td></tr><tr><td align="center">string  toString(int[] a)</td><td align="center">返回指定数组的字符串表示形式，方法也同样适用于（byte,short.,long等）</td></tr><tr><td align="center">List  asList(int[] a,int[] b)</td><td align="center">返回由指定数组支持的固定大小的列表，方法也同样适用于（byte,short.,long等）</td></tr></tbody></table></li><li><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖</title>
      <link href="/2022/10/30/rui-ji-wai-mai/"/>
      <url>/2022/10/30/rui-ji-wai-mai/</url>
      
        <content type="html"><![CDATA[<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul><li><p>后台系统</p><pre class="line-numbers language-none"><code class="language-none">   菜品管理（批量删除、起售停售）​套餐管理（修改、起售停售）​订单明细<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>移动端</p><pre class="line-numbers language-none"><code class="language-none">   个人中心（退出登录、最新订单查询、历史订单、地址管理-修改地址、地址管理-删除地址）​购物车（删除购物车中的商品)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>【未完待续。。。】</p>]]></content>
      
      
      <categories>
          
          <category> 项目篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatisplus </tag>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯——杨辉三角形</title>
      <link href="/2022/10/29/lan-qiao-bei-yang-hui-san-jiao-xing/"/>
      <url>/2022/10/29/lan-qiao-bei-yang-hui-san-jiao-xing/</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://s2.loli.net/2022/10/29/4yhwpENKvXW89iS.png" alt="image-20221029200859350"></p></li><li><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p><del>刚开始的想法是，定义一个二维数组，将每一行的数字都存进去，但是因为<font color='red'>N&lt;&#x3D;1000000000</font>，开二维数组导致内存超限。</del></p><p>​仔细思考后发现，既然按行不行，那就按列来算：第一列全为1，第二列为从1开始的自然数列，第三列的数为同行的第二列的数和它上一行第二列的数相乘以后除以二的结果。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">a[n][3]&#x3D;a[n][2]*a[n-1][2]&#x2F;2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​然后推断出，第三列的数大于1000000000时，相邻的第二列数为44723，这一行的个数为44724，这是第44724行，所以可以开一个一维数组a[44725],然后公式<font color='red'>a[j]&#x3D;a[j]+a[j-1]</font>,从每一行的最左端的数看为a[n]<font color='red'>(n为行数，n从0开始）</font>开始计算，将每一行的数都存入一维数组，然后从前一行的数推出后一行的数，如果遇到这个数就直接跳出，如果计算到第44723行的第三列数仍未找到，那这个数一定会出现在第二列的第N+1行。</p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class 杨辉三角 &#123;    public static void main(String[] args) &#123;        long N,count&#x3D;0;        int i&#x3D;1,j &#x3D; 2,p;        Scanner scanner &#x3D; new Scanner(System.in);        N&#x3D;scanner.nextLong();       long[] a&#x3D;new long[44725];       a[0]&#x3D;1;&#x2F;&#x2F;初始化第一行       if(N&#x3D;&#x3D;1)&#123;           System.out.println(1);           return;       &#125;       for(i&#x3D;1;i&lt;44725;i++)&#123;&#x2F;&#x2F;从第二行开始           for(j&#x3D;i;j&gt;&#x3D;1;j--)&#123;               &#x2F;&#x2F;重点               a[j]&#x3D;a[j]+a[j-1];               &#x2F;&#x2F;               count++;               if(a[j]&#x3D;&#x3D;N)&#123;                   System.out.println(count+i);&#x2F;&#x2F;加i是因为每一行都没有算a[0]                   return;               &#125;           &#125;       &#125;        System.out.println(N*(N+1)&#x2F;2+2);&#x2F;&#x2F;计算第二列第N+1行的数是第几个    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 习题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2022/10/25/pai-xu-suan-fa/"/>
      <url>/2022/10/25/pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><ul><li><strong>稳定</strong>：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面；</li><li><strong>原地排序</strong>：在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序；</li><li><strong>非原地排序</strong>：需要利用额外的数组来辅助排序；</li></ul></blockquote><p><strong>各排序算法总结：</strong></p><p><img src="https://s2.loli.net/2022/10/25/haZ7kNejPYqKlio.png" alt="image-20220911004032768"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>冒泡排序是一种简单的排序算法，每轮比较，将未排序的最大的数字放到最后，经过n-1轮，整个数组都有序了。</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY.gif"><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY.gif" alt="img"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 冒泡排序 * @param a * @return *&#x2F;public static int [] BubbleSort(int [] a)&#123;    if(a.length &#x3D;&#x3D; 0)        return a;    int len &#x3D; a.length;    for(int i&#x3D;0;i&lt;len;i++)&#123;        for(int j&#x3D;0;j&lt;len-i-1;j++)&#123;            &#x2F;&#x2F;交换两个相邻数字            if(a[j+1]&lt;a[j])&#123;                int temp &#x3D; a[j+1];                a[j+1] &#x3D; a[j];                a[j] &#x3D; temp;            &#125;        &#125;    &#125;    return a;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优化一下冒泡排序的算法</strong></p><blockquote><p>如果某一趟的遍历中，相邻的元素之间都没有发生交换的操作，这意味着右边的元素总是大于等于左边的元素，此时的数组已经是有序的了，我们无需再对剩余的元素重复比较下去了。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int[] bubbleSort(int[] arr) &#123;        if ( arr.length &#x3D;&#x3D; 0) &#123;            return arr;        &#125;        int len &#x3D; arr.length;        for (int i &#x3D; 0; i &lt; len; i++) &#123;            boolean flag &#x3D; true;            for (int j &#x3D; 0; j &lt; len -i - 1; j++) &#123;               if (arr[j + 1] &lt; arr[j]) &#123;                   flag &#x3D; false;                   int t &#x3D; arr[j];                   arr[j] &#x3D; arr[j+1];                   arr[j+1] &#x3D; t;               &#125;           &#125;           &#x2F;&#x2F;一趟下来是否发生位置交换           if(false)               break;       &#125;       return arr;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用优化后的冒泡算法，在数组本身就有序的情况下，时间复杂度为O(n)</strong></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>将数组分为已经排序和未排序两部分，初始时已排序部分元素个数为0。每次遍历，找到未排序数组中的最小元素，然后将它放在已排序数组中的末尾。经过n-1次遍历后，整个数组就是有序的了。</p><ul><li>初始状态：无序区为R[1…n]，有序区为空；</li><li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了</li></ul></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/2.gif"><img src="https://s2.loli.net/2022/10/25/3j4SH1MKDqXgoyR.gif" alt="img"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**     * 选择排序     * @param a     * @return     *&#x2F;    public static int [] SelectSort(int [] a)&#123;        if(a.length &#x3D;&#x3D; 0)            return a;        int len &#x3D; a.length;        for(int i&#x3D;0;i&lt;len;i++)&#123;            int minindex &#x3D; i;            &#x2F;&#x2F;遍历无序数组，找到最小的元素            for(int j&#x3D;i+1;j&lt;len;j++)&#123;                if(a[j] &lt; a[minindex])                    minindex &#x3D; j;            &#125;&#x2F;&#x2F;交换元素            int temp &#x3D; a[i];            a[i] &#x3D; a[minindex];            a[minindex] &#x3D; temp;        &#125;        return a;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>插入排序同样将数组分为已排序和未排序的两部分。每次遍历的时候都将当前元素和之前的元素进行比较，找到小于等于自己的元素，然后插入到他的后面；在比较过程中，大于当前元素的元素都将向后移动一位。</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/3.gif"><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/3.gif" alt="img"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 插入排序 * @param a * @return *&#x2F;public static int [] insertSort(int [] a)&#123;    if(a.length &#x3D;&#x3D; 0)        return a;    int len &#x3D; a.length;    for(int i&#x3D;1;i&lt;len;i++)&#123;        &#x2F;&#x2F;当前元素        int current &#x3D; a[i];        &#x2F;&#x2F;前一个元素的位置        int preindex &#x3D; i-1;        while(preindex&gt;&#x3D;0&amp;&amp;a[preindex] &gt; current)&#123;            &#x2F;&#x2F;将大于当前元素的值向后移动一位            a[preindex+1] &#x3D; a[preindex];            preindex--;        &#125;        &#x2F;&#x2F;退出循环是因为preindex&lt;0 或者 a[preindex] &lt;&#x3D; current        &#x2F;&#x2F;也就是说当前元素应该插入到preindex后面，所以+1        a[preindex+1] &#x3D; current;    &#125;    return a;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>希尔排序是插入排序的改进版，也叫缩小增量排序；插入排序每次只会和前面一个数字进行比较，<strong>如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n - 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了</strong>。而希尔排序会逐渐减小这个增量的值，随着增量逐渐减小，每组包含的元素越来越多，当增量为1的时候，整个数组被分成一组，算法终止。</p></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220911112014363.png"><img src="https://s2.loli.net/2022/10/25/WEvcmkY3jbDGShz.png" alt="image-20220911112014363"></a></p><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220911112014363.png">image-20220911112014363</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 希尔排序 * @param a * @return *&#x2F;public static int[] shellSort(int [] a)&#123;    if(a.length &#x3D;&#x3D; 0)        return a;    int len &#x3D; a.length;    &#x2F;&#x2F;增量选择为 len&#x2F;2，增量可以有多种选择方法    int gap &#x3D; len&#x2F;2;    while(gap&gt;0)&#123;        &#x2F;&#x2F;对于每一个增量，进行插入排序        for(int i&#x3D;gap;i&lt;len;i++)&#123;            int current &#x3D; a[i];            &#x2F;&#x2F;这里上一个元素的下标为当前下标-gap            int preindex &#x3D; i-gap;            while(preindex&gt;&#x3D;0 &amp;&amp; a[preindex]&gt;current)&#123;                a[preindex+gap] &#x3D; a[preindex];                preindex-&#x3D;gap;            &#125;            a[preindex+gap] &#x3D; current;        &#125;        gap&#x2F;&#x3D;2;    &#125;    return a;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>由上面代码可以看出，其实希尔排序就是插入排序的优化，代码也很像，只是需要每次对gap进行修改，并且元素之间的间隔不再是固定的1，而是这个gap。</strong></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>归并排序是分治法的一个典型应用。将一个大的数组分为多个子序列，对每个子序列进行排序，然后再将已经有序的子序列进行合并，得到最终的有序序列，即：<strong>先让每个子序列有序，再让子序列段间有序。</strong></p><ul><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列</li></ul></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/4.gif"><img src="https://s2.loli.net/2022/10/25/aTpP2KuOHs8mqzg.gif" alt="img"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 归并排序 * @param a * @param left * @param right * @return *&#x2F;public static int [] mergeSort(int [] a,int left,int right)&#123;    if(left &lt; right)&#123;        &#x2F;&#x2F;将大数组分成两个子数组        int mid &#x3D; left+(right-left)&#x2F;2;        &#x2F;&#x2F;对左半边进行排序        mergeSort(a,left,mid);        &#x2F;&#x2F;对右半边进行排序        mergeSort(a,mid+1,right);        &#x2F;&#x2F;合并        merge(a,left,mid,right);    &#125;    return a;&#125;public static void merge(int [] a,int left,int mid,int right)&#123;    int [] temp &#x3D; new int [right-left+1];    int i &#x3D; left;    int j&#x3D; mid+1;    int k&#x3D;0;    while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;right)&#123;        if(a[i] &lt; a[j])            temp[k++] &#x3D; a[i++];        else            temp[k++] &#x3D; a[j++];    &#125;    while(i&lt;&#x3D;mid)        temp[k++] &#x3D; a[i++];    while(j&lt;&#x3D;right)        temp[k++]&#x3D; a[j++];    &#x2F;&#x2F;将临时数组的元素复制到原数组    for(i&#x3D;0;i&lt;k;i++)&#123;        a[left++] &#x3D; temp[i];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>快速排序是选择一个基准数，将大于基准数的元素放在基准数右边，小于基准数的元素放在基准数左边。这是基准数的位置就是有序的了；在分别对左右两个子序列进行同样操作，最后达到有序。</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot ）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/5.gif"><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/5.gif" alt="img"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 快速排序 * @param * @param left 数组的左边界 * @param right 数组的右边界 * @return *&#x2F;public static void QuickSort(int[] nums, int left, int right)&#123;    if(left &lt; right)&#123;        &#x2F;&#x2F;找到基准数的有序下表        int mid &#x3D; Partition(nums,left,right);        &#x2F;&#x2F;将数组分为两部分，递归分区操作        QuickSort(nums,left,mid-1);        QuickSort(nums,mid+1,right);    &#125;&#125;public static int Partition(int []nums,int left,int right)&#123;    &#x2F;&#x2F;默认数组的第一个为基准数    int pivot &#x3D; nums[left];    int i &#x3D; left+1;    int j &#x3D; right;    while(true)&#123;        &#x2F;&#x2F;从左到右找到数组中大于基准数的值        while(i&lt;&#x3D;j &amp;&amp; nums[i] &lt;&#x3D; pivot)            i++;        &#x2F;&#x2F;从右向左找到数组中小于基准数的值        while(i&lt;&#x3D;j &amp;&amp; nums[j] &gt;&#x3D; pivot)            j--;        if(i&gt;&#x3D;j)            break;        &#x2F;&#x2F;交换这两个数，让&lt; 基准数的元素到基准数左边，&gt; 基准数的元素到基准数右边        int t &#x3D; nums[i];        nums[i] &#x3D; nums[j];        nums[j] &#x3D; t;    &#125;    &#x2F;&#x2F;将基准数放到中间，此时基准数位置有序    nums[left] &#x3D; nums[j];    nums[j] &#x3D; pivot;    return j;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>另外一种快速排序</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;随机选取基准数public static void QuickSort(int[] nums, int left, int right)&#123;        if(left &lt; right)&#123;            &#x2F;&#x2F;随机选取基准数            int randomIndex &#x3D; new Random().nextInt(right-left)+left+1;            &#x2F;&#x2F;将基准数放在数组的首部            swap(nums,left,randomIndex);            int mid &#x3D; Partition(nums,left,right);            QuickSort(nums,left,mid-1);            QuickSort(nums,mid+1,right);        &#125;    &#125;public static int Partition(int [] a,int left,int right)&#123;    int pivot &#x3D; left,index &#x3D; left+1;    &#x2F;&#x2F;此时right是下标值，因此是&lt;&#x3D;    for(int i&#x3D;index;i&lt;&#x3D;right;i++)&#123;        &#x2F;&#x2F;将小于基准数的元素放在前面来，index表示不小于基准数的第一个下标        if(a[i] &lt; a[pivot])&#123;            swap(a,index,i);            index++;        &#125;    &#125;    &#x2F;&#x2F;index由于每次执行+1，所以最后一个小于基准数的是index-1    swap(a,index-1,pivot);    return index-1;&#125;&#x2F;&#x2F;交换两个元素public static void swap(int [] a,int left,int right)&#123;    int temp &#x3D; a[left];    a[left] &#x3D; a[right];    a[right] &#x3D; temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在选择基准数的时候，如果每次选取的都是当前子序列中的最小值或者最大值，那么经过一次遍历之后，其他元素的位置没有变化。那么就有点像选择排序，时间复杂度为O(n²)。当数组已经有序时，如果选择的不是随机基准数会出现这种情况。</strong></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>堆排序是利用堆这种数据结构，构建一个大顶堆，将大顶堆的堆顶元素与堆的最后一个值进行交换，并重新构建大顶堆。由大顶堆堆顶是最大值，因此交换之后数组的最后一个值为最大值，此时有序。</p><p><strong>大顶堆性质：子节点的值一定小于父节点的值。</strong></p><p><strong>在数组中，2*index+1是左节点，2*index+2是左节点</strong></p></blockquote><p><a href="https://pety.oss-cn-shenzhen.aliyuncs.com/img/7.gif"><img src="https://s2.loli.net/2022/10/25/kltenw6VBco41IM.gif" alt="img"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 堆排序 * @param nums *&#x2F;public static void heapSort(int [] nums)&#123;    int len &#x3D; nums.length;    &#x2F;&#x2F;构架大顶堆    buildMaxHeap(nums,len-1);    for(int i &#x3D; len-1;i&gt;&#x3D;1;i--)&#123;        &#x2F;&#x2F;将堆顶放到数组末尾，因为堆顶是最大值，经过这次，最大值有序        int temp &#x3D; nums[i];        nums[i] &#x3D; nums[0];        nums[0] &#x3D; temp;        &#x2F;&#x2F;通过下沉重新构建大顶堆        adjustHeap(nums,0,i-1);    &#125;&#125;&#x2F;** * 构建大顶堆 * @param nums *&#x2F;public static void buildMaxHeap(int [] nums,int length)&#123;    &#x2F;&#x2F;根据大顶堆的特性，一个字节的值大于等于其子节点的值    &#x2F;&#x2F;所以需要调节每一个有子节点的节点和它的子节点的关系。    &#x2F;&#x2F;因此从(length-1)&#x2F;2开始，这是最后一个非叶子节点    for(int i&#x3D;(length-1)&#x2F;2;i&gt;&#x3D;0;i--)&#123;        &#x2F;&#x2F;对非叶子节点通过下沉来构架大顶堆,        adjustHeap(nums,i,length);    &#125;&#125;&#x2F;** * 下沉操作 * @param nums * @param parent * @param n *&#x2F;public static void adjustHeap(int []nums,int parent,int n)&#123;    &#x2F;&#x2F;记录当前值    int temp &#x3D; nums[parent];    &#x2F;&#x2F;左孩子    int child &#x3D; 2*parent+1;    while(child &lt;&#x3D;n)&#123;        &#x2F;&#x2F;需要将子节点中较大值和父节点进行比较        &#x2F;&#x2F;经过这个if，child是子节点中的较大值        if(child+1&lt;&#x3D;n&amp;&amp;nums[child] &lt; nums[child+1])            child++;        if(nums[child] &lt;&#x3D;temp)            break;        &#x2F;&#x2F;将子节点上浮到父节点位置，父节点下沉到子节点位置        nums[parent] &#x3D; nums[child];        parent &#x3D; child;        child &#x3D; 2*parent+1;    &#125;    nums[parent] &#x3D; temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建时踩过的坑</title>
      <link href="/2022/10/23/ge-ren-bo-ke-da-jian-shi-cai-guo-de-keng/"/>
      <url>/2022/10/23/ge-ren-bo-ke-da-jian-shi-cai-guo-de-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>​经过这几天的忙碌，我的博客也差不多大功告成，当然还有一些细节需要优化。这篇文章主要是对我在搭建博客的过程中踩过的坑做一个总结，希望能帮到遇到同样bug的人。</p></blockquote><h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><ul><li><p>node.js</p></li><li><p>git</p></li><li><p>编辑器（例如：IntelliJ IDEA、VScode)</p></li></ul><p>（温馨提示：node.js安装后需要配置环境变量，本文不做详细介绍，可自行Google，不难，另外最好不要去官网下载，速度特别慢）</p><h2 id="在Github下建自己的博客仓库"><a href="#在Github下建自己的博客仓库" class="headerlink" title="在Github下建自己的博客仓库"></a>在Github下建自己的博客仓库</h2><p>​仓库名称最好为”你的github名称.github.io”,另外github账户名称最好不要用大写字母。</p><h2 id="使用hexo-script脚本安装hexo"><a href="#使用hexo-script脚本安装hexo" class="headerlink" title="使用hexo-script脚本安装hexo"></a>使用hexo-script脚本安装hexo</h2><p>​以上操作完成无误后，首先需要新建一个目录blog，然后<a href="https://hexoscript.gitbook.io/hexo-script/v/1.3-1/shi-yong-bu-zhou/zhun-bei-gong-ju">点击这里</a>进入到下方页面</p><p><img src="https://s2.loli.net/2022/10/24/LzxshrMYy5XNc3d.png" alt="image-20221024215200630"></p><p>​根据上面的教程可以自行安装。</p><h2 id="我踩过的的坑"><a href="#我踩过的的坑" class="headerlink" title="我踩过的的坑"></a>我踩过的的坑</h2><ul><li><h3 id="设置SSH密匙"><a href="#设置SSH密匙" class="headerlink" title="设置SSH密匙"></a>设置SSH密匙</h3><p>​首先在执行教程时，一定要检查自己的C:\Users\你的用户名.ssh路径下是否包含以下两个文件，没有的话需要在桌面单击右键打开git bash窗口，输入以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C  &quot;2018XXXX98@qq.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>记得换成自己的邮箱</p></li></ul><p><img src="https://s2.loli.net/2022/10/24/TFodyqrngvQYupf.png" alt="image-20221024220044123"></p><p>然后到自己的github中进行以下设置<img src="https://s2.loli.net/2022/10/24/1iukBstCrXwKpyR.png" alt="image-20221024220943278"></p><ul><li><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><ol><li><p>​刚开始部署博客时如果无论如何都无法出现博客首页，一定要到自己的github仓库下，点击setting，进行如下设置：<img src="https://s2.loli.net/2022/10/24/w3cnJxjahrQDHCp.png" alt="image-20221024221543301"></p></li><li><p>​        使用Git将博客部署到远程仓库时，使用的命令依次是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean  &#x2F;&#x2F;清理之前的部署hexo g      &#x2F;&#x2F;在hexo站点根目录下生成public文件夹hexo s      &#x2F;&#x2F;在本地开启hexo，可跳过hexo d      &#x2F;&#x2F;将代码提交到远程仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>​        执行<strong>hexo   d</strong>是出现<strong>Spawn failed</strong>错误</p></li><li><p><img src="https://s2.loli.net/2022/10/29/PLlI2Dhg1aeZXQn.png" alt="image-20221029193638212"></p><ul><li>问题原因<ol><li>Git向远程仓库push文件的时候发生更改</li><li>网络原因</li></ol></li><li>解决方法</li></ul><p>首先进入自己博客的根目录，删除**.deploy_git<strong>文件，然后在</strong>git bash**中执行下面代码：</p><pre class="line-numbers language-none"><code class="language-none">git config --global core.autocrlf false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后重新进行部署。</p></li></ol></li><li><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>​       一般部署好自己的个人网站后都会更换主题，我的主题是<a href="https://github.com/blinkfox/hexo-theme-matery">matery</a>，当然大家可以<a href="https://hexo.io/themes/index.html">单击这里</a>选择自己心仪的主题,基本的配置大家都可以参考配置文档。</p><p>我的blog首页：</p><p><img src="https://s2.loli.net/2022/10/24/BdAtKO3uQylYzWR.png" alt="image-20221024223151003"></p></li><li><h3 id="添加valine评论功能"><a href="#添加valine评论功能" class="headerlink" title="添加valine评论功能"></a>添加valine评论功能</h3><ul><li>问题描述</li></ul><p> ​       参照配置文档开启valine评论功能之后，结果发现不仅在标签、分类、归档、友链下面全部出现了评论功能，而我只需要在留言板下出现评论功能即可，在网上找了很久，居然没有一篇文章提到这个问题。</p><ul><li>解决方法</li></ul><p> ​     只需要在标签、分类、归档目录下的index.md文件的front matter中的comments标签设置为false即可。</p><p> <img src="https://s2.loli.net/2022/10/29/agyTF36k9rjMOhB.png" alt="image-20221029172759947"></p><ul><li><p>不足</p><p>​       使用上述方法后，在标签、分类、归档标签页下有效，但是友链下面虽然设置了comment: false,仍然出现valine评论，后续有待完善。</p></li></ul><p></p></li><li><h3 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="[未完待续。。。]"></a>[未完待续。。。]</h3></li><li><h3 id="网站提速"><a href="#网站提速" class="headerlink" title="网站提速"></a>网站提速</h3><p>将主题目录下的_config.yml文件中的js和css中的内容替换成国内的CDN。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> matery </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
